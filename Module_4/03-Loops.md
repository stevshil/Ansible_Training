# Loops

Reference: https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_loops.html

Earlier we saw the **for** loop being used in templates.  Ansible playbooks also provide a form of looping, allowing us to use the same task for multiple values.

We have also seen it in some of the playbooks we have written, in particular the **database** playbook, when installing packages.

The installation of packages is a classic example of reusing the same task for multiple values.  As a reminder, here is what the database playbook task looked like:

```yaml
    - name: Install MariaDB package
        package:
          name:
            - mariadb-server
            - mariadb-client
            - python3-pymysql
```

The loop is provided to this module by the ability to list multiple package names in the **name** section.  Ansible identifies this as a requirement to process all the packages.

The same process could be written using the **with_items** statement, but Ansible will complain that this is deprecated and should be written as above.

There are still modules that will require the use of the Ansible loop **with_items**.

Typical uses might be:

* Setting the permissions on multiple files
  * Can be done using the **with_fileglob** loop to capture all files in a directory
  * Can be used with **with_items** and specifically listing the files required
* Creating user accounts
* Loop through host groups
* Loop through nodes in a host group
* And more

Let's take a look at a simple loop using with_items to create 3 files of the same content and then set their permissions.

```yaml
- name: Loop playbook
  hosts: controller

  tasks:

  - name: Create a directory for our files
    ansible.builtin.file:
        path: /tmp/aloop
        state: directory
        mode: 0755

  - name: Create 3 files using copy
    ansible.builtin.copy:
        dest: "/tmp/aloop/{{ item }}"
        content: This data is generated by Ansible
    with_items:
        - file1
        - file2
        - file3

  - name: Set permissions as readonly to user
    ansible.builtin.file:
        path: "{{ item }}"
        mode: 0400
    with_fileglob: "/tmp/aloop/*"
```

In the above example you can see that we have made use of the **with_items** to specify the file names we wish to create in that directory, and the **{{ item }}** variable which will be used as a placeholder in our code for the file names at run time.  We have also used the **with_fileglob** to obtain all the files in the **/tmp/aloop** directory, and then used the **{{ item }}** variable again for the setting permissions task.

Save the file and run the playbook.  You should see for the file creation and permissions 3 outputs, 1 for each item for these tasks.  This is slightly different to the way Ansible did the **package** loop as it does not show output for each package.

After running the playbook you can list the new directory to see the outcome:

```sh
$ ls -l /tmp/aloop

total 12
-r-------- 1 ansible ansible 33 Sep 17 09:08 file1
-r-------- 1 ansible ansible 33 Sep 17 09:08 file2
-r-------- 1 ansible ansible 33 Sep 17 09:08 file3
```

## Generating a list

The **package** module and the operating specific package commands such as **apt** and **yum** allow us to provide a list of values.  If our packages were stored in a variable that is a list then we can simply supply that variable to the **name** attribute as normal.  However, if you have a file with a list of packages, then you may want to turn the contents of that file into an Ansible list.  To do that we can make use the **lookup** command.

Lookup reference: https://docs.ansible.com/ansible/latest/plugins/lookup.html

The lookup and loop commands work as follows:

```yaml
- name: Using lookup
  hosts: controller

  vars:
    packages: "{{ lookup('file', './mypackages') }}"
    packages_list: "{{ packages | split('\n') }}"

  tasks:
    - name: Show packages as string
      ansible.builtin.debug:
        msg: "{{ packages }}"

    - name: Show  packages as list
      ansible.builtin.debug:
        msg: "{{ item }}"
      loop: "{{ packages_list }}"
```

When you save and run the playbook you'll see that the lookup has extracted the data from the file, but as a string, separated by **\n**.  We then process that further by splitting the string into a list.  In the final debug statement you'll notice that 3 executions of the code occur, one for each package name.

Perhaps you have a file of user names from HR that need to have their account provisioned.

Let's take a look at how that might work:

1. Create a file called **usersFromHR.txt**
2. In that file add the following:
    steve
    john
    george
3. Save the file
4. Create a new playbook called **useraccounts.yml**
5. Write the following code into that file:

```yaml
- name: Add user accounts from HR
  hosts:
    - databases
    - webservers

  vars:
    users_from_file: "{{ lookup('file', './usersFromHR.txt') }}"
    user_accounts: "{{ users_from_file | split('\n') }}"

  tasks:
    - name: Create user accounts
      ansible.builtin.user:
        name: "{{ item }}"
        shell: /bin/bash
        generate_ssh_key: true
        password: secret123
        state: present
        umask: 0077
      loop: "{{ user_accounts }}"
```

6. Save and run the playbook.
7. You'll notice that the **vars** section is dealt with on the controller, so the user account variables are set up prior to the tasks executing.
8. On completion you should have 3 new users on your database and web servers.  To check this log on to one of the hosts, and run the following:
    ```sh
    $ tail /etc/passwd
    # You should see steve, john and george as the last 3 lines
    $ sudo ls -l /home/george/.ssh
    # You should see that the SSH keys were created
    ```
